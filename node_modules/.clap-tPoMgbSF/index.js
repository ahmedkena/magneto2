var MAX_LINE_WIDTH = process.stdout.columns || 200;
var MIN_OFFSET = 25;

var errorHandler;
var commandsPath;

var reAstral = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var ansiRegex = /\x1B\[([0-9]{1,3}(;[0-9]{1,3})*)?[m|K]/g;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function stringLength(str){
  return str
    .replace(ansiRegex, '')
    .replace(reAstral, ' ')
    .length;
}

function camelize(name){
  return name.replace(/-(.)/g, function(m, ch){
    return ch.toUpperCase();
  });
}

function assign(dest, source){
  for (var key in source)
    if (hasOwnProperty.call(source, key))
      dest[key] = source[key];

  return dest;
}

function returnFirstArg(value){
  return value;
}

function pad(width, str){
  return str + Array(Math.max(0, width - stringLength(str)) + 1).join(' ');
}

function noop(){
  // nothing todo
}

function parseParams(str){
  // params [..<required>] [..[optional]]
  // <foo> - require
  // [foo] - optional
  var tmp;
  var left = str.trim();
  var result = {
    minArgsCount: 0,
    maxArgsCount: 0,
    args: []
  };

  do {
    tmp = left;
    left = left.replace(/^<([a-zA-Z][a-zA-Z0-9\-\_]*)>\s*/, function(m, name){
      result.args.push(new Argument(name, true));
      result.minArgsCount++;
      result.maxArgsCount++;

      return '';
    });
  }
  while (tmp != left);

  do {
    tmp = left;
    left = left.replace(/^\[([a-zA-Z][a-zA-Z0-9\-\_]*)\]\s*/, function(m, name){
      result.args.push(new Argument(name, false));
      result.maxArgsCount++;

      return '';
    });
  }
  while (tmp != left);

  if (left)
    throw new SyntaxError('Bad parameter description: ' + str);

  return result.args.length ? result : false;
}

/**
* @class
*/

var SyntaxError = function(message){
  this.message = message;
};
SyntaxError.prototype = Object.create(Error.prototype);
SyntaxError.prototype.name = 'SyntaxError';
SyntaxError.prototype.clap = true;

/**
* @class
*/
var Argument = function(name, required){
  this.name = name;
  this.required = required;
};
Argument.prototype = {
  required: false,
  name: '',
  normalize: returnFirstArg,
  suggest: function(){
    return [];
  }
};

/**
* @class
* @param {string} usage
* @param {string} description
*/
var Option = function(usage, description){
  var self = this;
  var params;
  var left = usage.trim()
    // short usage
    // -x
    .replace(/^-([a-zA-Z])(?:\s*,\s*|\s+)/, function(m, name){
      self.short = name;

      return '';
    })
    // long usage
    // --flag
    // --no-flag - invert value if flag is boolean
    .replace(/^--([a-zA-Z][a-zA-Z0-9\-\_]+)\s*/, function(m, name){
      self.long = name;
      self.name = name.replace(/(^|-)no-/, '$1');
      self.defValue = self.name != self.long;

      return '';
    });

  if (!this.long)
    throw new SyntaxError('Usage has no long name: ' + usage);

  try {
    params = parseParams(left);
  } catch(e) {
    throw new SyntaxError('Bad paramenter description in usage for option: ' + usage, e);
  }

  if (params)
  {
    left = '';
    this.name = this.long;
    this.defValue = undefined;

    assign(this, params);
  }

  if (left)
    throw new SyntaxError('Bad usage description for option: ' + usage);

  if (!this.name)
    this.name = this.long;

  this.description = description || '';
  this.usage = usage.trim();
  this.camelName = camelize(this.name);
};

Option.prototype = {
  name: '',
  description: '',
  short: '',
  long: '',

  beforeInit: false,
  required: false,
  minArgsCount: 0,
  maxArgsCount: 0,
  args: null,

  defValue: undefined,
  normalize: returnFirstArg
};


//
// Command
//

function createOption(usage, description, opt_1, opt_2){
  var option = new Option(usage, description);

  // if (option.bool && arguments.length > 2)
  //   throw new SyntaxError('bool flags can\'t has default value or validator');

  if (arguments.length == 3)
  {
    if (opt_1 && opt_1.constructor === Object)
    {
      for (var key in opt_1)
        if (key == 'normalize' ||
            key == 'defValue' ||
            key == 'beforeInit')
          option[key] = opt_1[key];

      // old name for `beforeInit` setting is `hot`
      if (opt_1.hot)
        option.beforeInit = true;
    }
    else
    {
      if (typeof opt_1 == 'function')
        option.normalize = opt_1;
      else
        option.defValue = opt_1;
    }
  }

  if (arguments.length == 4)
  {
    if (typeof opt_1 == 'function')
      option.normalize = opt_1;

    option.defValue = opt_2;
  }

  return option;
}

function addOptionToCommand(command, option){
  var commandOption;

  // short
  if (option.short)
  {
    commandOption = command.short[option.short];

    if (commandOption)
      throw new SyntaxError('Short option name -' + option.short + ' already in use by ' + commandOption.usage + ' ' + commandOption.description);

    command.short[option.short] = option;
  }

  // long
  commandOption = command.long[option.long];

  if (commandOption)
    throw new SyntaxError('Long option --' + option.long + ' already in use by ' + commandOption.usage + ' ' + commandOption.description);

  command.long[option.long] = option;

  // camel
  commandOption = command.options[option.camelName];

  if (commandOption)
    throw new SyntaxError('Name option ' + option.camelName + ' already in use by ' + commandOption.usage + ' ' + commandOption.description);

  command.options[option.camelName] = option;

  // set default value
  if (typeof option.defValue != 'undefined')
    command.setOption(option.camelName, option.defValue, true);

  // add to suggestions
  command.suggestions.push('--' + option.long);

  return option;
}

function findVariants(obj, entry){
  return obj.suggestions.filter(function(item){
    return item.substr(0, entry.length) == entry;
  });
}

function processArgs(command, args, suggest){
  function processOption(option, command){
    var params = [];

    if (option.maxArgsCount)
    {
      for (var j = 0; j < option.maxArgsCount; j++)
      {
        var suggestPoint = suggest && i + 1 + j >= args.length - 1;
        var nextToken = args[i + 1];

        // TODO: suggestions for options
        if (suggestPoint)
        {
          // search for suggest
          noSuggestions = true;
          i = args.length;
          return;
        }

        if (!nextToken || nextToken[0] == '-')
          break;

        params.push(args[++i]);
      }

      if (params.length < option.minArgsCount)
        throw new SyntaxError('Option ' + token + ' should be used with at least ' + option.minArgsCount + ' argument(s)\nUsage: ' + option.usage);

      if (option.maxArgsCount