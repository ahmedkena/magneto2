"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrustedMetadataStore = void 0;
const models_1 = require("@tufjs/models");
const error_1 = require("./error");
class TrustedMetadataStore {
    constructor(rootData) {
        this.trustedSet = {};
        // Client workflow 5.1: record fixed update start time
        this.referenceTime = new Date();
        // Client workflow 5.2: load trusted root metadata
        this.loadTrustedRoot(rootData);
    }
    get root() {
        if (!this.trustedSet.root) {
            throw new ReferenceError('No trusted root metadata');
        }
        return this.trustedSet.root;
    }
    get timestamp() {
        return this.trustedSet.timestamp;
    }
    get snapshot() {
        return this.trustedSet.snapshot;
    }
    get targets() {
        return this.trustedSet.targets;
    }
    getRole(name) {
        return this.trustedSet[name];
    }
    updateRoot(bytesBuffer) {
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newRoot = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);
        if (newRoot.signed.type != models_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(`Expected 'root', got ${newRoot.signed.type}`);
        }
        // Client workflow 5.4: check for arbitrary software attack
        this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);
        // Client workflow 5.5: check for rollback attack
        if (newRoot.signed.version != this.root.signed.version + 1) {
            throw new error_1.BadVersionError(`Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`);
        }
        // Check that new root is signed by self
        newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);
        // Client workflow 5.7: set new root as trusted root
        this.trustedSet.root = newRoot;
        return newRoot;
    }
    updateTimestamp(bytesBuffer) {
        if (this.snapshot) {
            throw new error_1.RuntimeError('Cannot update timestamp after snapshot');
        }
        if (this.root.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError('Final root.json is expired');
        }
        const data = JSON.parse(bytesBuffer.toString('utf8'));
        const newTimestamp = models_1.Metadata.fromJSON(models_1.MetadataKind.Timestamp, data);
        if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {
            throw new error_1.RepositoryError(`Expected 'timestamp', got ${newTimestamp.signed.type}`);
        }
        // Client workflow 5.4.2: check for arbitrary software attack
        this.root.verifyDelegate(models_1.MetadataKind.Timestamp, newTimestamp);
        if (this.timestamp) {
            // Prevent rolling back timestamp version
            // Client workflow 5.4.3.1: check for rollback attack
            if (newTimestamp.signed.version < this.timestamp.signed.version) {
                throw new error_1.BadVersionError(`New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`);
            }
            //  Keep using old timestamp if versions are equal.
            if (newTimestamp.signed.version === this.timestamp.signed.version) {
                throw new error_1.EqualVersionError(`New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`);
            }
            // Prevent rolling back snapshot version
            // Client workflow 5.4.3.2: check for rollback attack
            const snapshotMeta = this.timestamp.signed.snapshotMeta;
            const newSnapshotMeta = newTimestamp.signed.snapshotMeta;
            if (newSnapshotMeta.version < snapshotMeta.version) {
                throw new error_1.BadVersionError(`New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`);
            }
        }
        // expiry not checked to allow old timestamp to be used for rollback
        // protection of n